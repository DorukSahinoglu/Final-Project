import random
import math
import re
from typing import List, Tuple, Dict

Chromosome = List[int]
Route = List[int]

DEPOT = 0


TAXI_CAPACITY = 4
MAX_TRUCKS = 999 


FIXED_TAXI_COST = 0
COST_PER_KM = 1



def tsplib_euc2d(p: Tuple[float, float], q: Tuple[float, float]) -> int:
   
    dx = p[0] - q[0]
    dy = p[1] - q[1]
    return int(math.sqrt(dx * dx + dy * dy) + 0.5)


def parse_k_from_name(text: str) -> int | None:
   
    m = re.search(r"NAME\s*:\s*.*?-k(\d+)\b", text, flags=re.IGNORECASE)
    if not m:
        return None
    return int(m.group(1))


def parse_name(text: str) -> str | None:
    m = re.search(r"NAME\s*:\s*(.+)", text, flags=re.IGNORECASE)
    if not m:
        return None
    return m.group(1).strip()


def parse_cvrp_tsplib(text: str):
   
    lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
    capacity = None
    dimension = None

    coords: Dict[int, Tuple[float, float]] = {}
    demand_raw: Dict[int, int] = {}
    depot_nodes: List[int] = []

    i = 0
    while i < len(lines):
        ln = lines[i]

        if ln.startswith("CAPACITY"):
            capacity = int(ln.split(":")[1].strip())
            i += 1
            continue

        if ln.startswith("DIMENSION"):
            dimension = int(ln.split(":")[1].strip())
            i += 1
            continue

        if ln.startswith("NODE_COORD_SECTION"):
            i += 1
            while i < len(lines) and not lines[i].startswith("DEMAND_SECTION"):
                parts = lines[i].split()
                node = int(parts[0])
                x = float(parts[1])
                y = float(parts[2])
                coords[node] = (x, y)
                i += 1
            continue

        if ln.startswith("DEMAND_SECTION"):
            i += 1
            while i < len(lines) and not lines[i].startswith("DEPOT_SECTION"):
                parts = lines[i].split()
                node = int(parts[0])
                dem = int(parts[1])
                demand_raw[node] = dem
                i += 1
            continue

        if ln.startswith("DEPOT_SECTION"):
            i += 1
            while i < len(lines):
                v = lines[i].split()[0]
                if v == "-1":
                    break
                depot_nodes.append(int(v))
                i += 1
            i += 1
            continue

        i += 1

    if capacity is None or dimension is None:
        raise ValueError("CAPACITY/DIMENSION parse edilemedi.")
    if len(depot_nodes) != 1:
        raise ValueError(f"Bu kod tek depot bekliyor. Bulunan depot_nodes={depot_nodes}")
    depot = depot_nodes[0]

    
    original_customers = [k for k in sorted(coords.keys()) if k != depot]
    if len(original_customers) != dimension - 1:
        raise ValueError("Customer sayısı dimension-1 ile uyuşmuyor.")

    old_to_new: Dict[int, int] = {depot: 0}
    for new_id, old_id in enumerate(original_customers, start=1):
        old_to_new[old_id] = new_id

    new_coords: List[Tuple[float, float]] = [(-1.0, -1.0)] * dimension
    for old_id, xy in coords.items():
        new_coords[old_to_new[old_id]] = xy

    demands: List[int] = [0] * dimension
    for old_id, dem in demand_raw.items():
        demands[old_to_new[old_id]] = dem

    if demands[0] != 0:
        raise ValueError("Depot demand 0 olmalı.")

    n = dimension
    distance_matrix: List[List[int]] = [[0] * n for _ in range(n)]
    for a in range(n):
        for b in range(n):
            if a == b:
                distance_matrix[a][b] = 0
            else:
                distance_matrix[a][b] = tsplib_euc2d(new_coords[a], new_coords[b])

  
    time_matrix: List[List[int]] = [[0] * n for _ in range(n)]

    return distance_matrix, time_matrix, demands, capacity



def route_distance(route: Route, dist: List[List[float]]) -> float:
    if not route:
        return 0.0
    total = dist[DEPOT][route[0]]
    for i in range(len(route) - 1):
        total += dist[route[i]][route[i + 1]]
    total += dist[route[-1]][DEPOT]
    return total


def route_duration(route: Route, time: List[List[float]]) -> float:
    if not route:
        return 0.0
    total = time[DEPOT][route[0]]
    for i in range(len(route) - 1):
        total += time[route[i]][route[i + 1]]
    total += time[route[-1]][DEPOT]
    return total


def random_giant_tour(n_customers: int, rng: random.Random) -> Chromosome:
    tour = list(range(1, n_customers + 1))
    rng.shuffle(tour)
    return tour


class Individual:
    def __init__(self, chromosome: Chromosome):
        self.chromosome = chromosome[:]

        self.f1_total_cost: float = float("inf")
        self.f2_max_route_duration: float = float("inf")
        self.f3_avg_route_duration: float = float("inf")

        self.rank: int = 10**9
        self.crowding: float = 0.0

        self.domination_set: List["Individual"] = []
        self.domination_count: int = 0


def init_population(pop_size: int, n_customers: int, seed: int = 46) -> List[Individual]:
    rng = random.Random(seed)
    pop: List[Individual] = []
    for _ in range(pop_size):
        chrom = random_giant_tour(n_customers, rng)
        pop.append(Individual(chrom))
    return pop


def ox_crossover(p1: Chromosome, p2: Chromosome, rng: random.Random) -> Tuple[Chromosome, Chromosome]:
    n = len(p1)
    assert n == len(p2)

    a, b = sorted(rng.sample(range(n), 2))

    def make_child(parent_a: Chromosome, parent_b: Chromosome) -> Chromosome:
        child = [-1] * n
        child[a:b + 1] = parent_a[a:b + 1]
        used = set(child[a:b + 1])

        idx = (b + 1) % n
        for gene in parent_b:
            if gene in used:
                continue
            child[idx] = gene
            idx = (idx + 1) % n
        return child

    c1 = make_child(p1, p2)
    c2 = make_child(p2, p1)
    return c1, c2


def swap_mutation(ch: Chromosome, rng: random.Random) -> Chromosome:
    n = len(ch)
    i, j = rng.sample(range(n), 2)
    out = ch[:]
    out[i], out[j] = out[j], out[i]
    return out


def inversion_mutation(ch: Chromosome, rng: random.Random) -> Chromosome:
    n = len(ch)
    i, j = sorted(rng.sample(range(n), 2))
    out = ch[:]
    out[i:j + 1] = reversed(out[i:j + 1])
    return out


def make_offspring(
    parents: List[Individual],
    rng: random.Random,
    crossover_rate: float = 0.9,
    mutation_rate: float = 0.02,
    mutation_kind: str = "swap"
) -> List[Individual]:

    offspring: List[Individual] = []
    n = len(parents)

    def mutate(ch: Chromosome) -> Chromosome:
        if mutation_kind == "inversion":
            return inversion_mutation(ch, rng)
        return swap_mutation(ch, rng)

    i = 0
    while len(offspring) < n:
        p1 = parents[i % n].chromosome
        p2 = parents[(i + 1) % n].chromosome
        i += 2

        if rng.random() < crossover_rate:
            c1, c2 = ox_crossover(p1, p2, rng)
        else:
            c1, c2 = p1[:], p2[:]

        if rng.random() < mutation_rate:
            c1 = mutate(c1)
        if rng.random() < mutation_rate:
            c2 = mutate(c2)

        offspring.append(Individual(c1))
        if len(offspring) < n:
            offspring.append(Individual(c2))

    return offspring
def apply_duplicate_penalty(pop: List["Individual"], penalty_step: float = 10.0) -> None:
    
    buckets = {}
    for ind in pop:
        key = tuple(ind.chromosome)          
        buckets.setdefault(key, []).append(ind)

    for inds in buckets.values():
        if len(inds) <= 1:
            continue
      
        for k, ind in enumerate(inds):
            if k == 0:
                continue
            ind.f1_total_cost += k * penalty_step


def dominates(a: "Individual", b: "Individual") -> bool:
    a_vals = (a.f1_total_cost, a.f2_max_route_duration, a.f3_avg_route_duration)
    b_vals = (b.f1_total_cost, b.f2_max_route_duration, b.f3_avg_route_duration)

    no_worse_all = True
    better_at_least_one = False

    for av, bv in zip(a_vals, b_vals):
        if av > bv:
            no_worse_all = False
            break
        if av < bv:
            better_at_least_one = True

    return no_worse_all and better_at_least_one


def fast_non_dominated_sort(population: List["Individual"]) -> List[List["Individual"]]:
    for p in population:
        p.domination_set = []
        p.domination_count = 0
        p.rank = 10**9

    fronts: List[List[Individual]] = []
    F1: List[Individual] = []

    for i, p in enumerate(population):
        for j in range(i + 1, len(population)):
            q = population[j]
            if dominates(p, q):
                p.domination_set.append(q)
                q.domination_count += 1
            elif dominates(q, p):
                q.domination_set.append(p)
                p.domination_count += 1

    for p in population:
        if p.domination_count == 0:
            p.rank = 1
            F1.append(p)

    fronts.append(F1)

    k = 0
    while k < len(fronts) and fronts[k]:
        next_front: List[Individual] = []
        for p in fronts[k]:
            for q in p.domination_set:
                q.domination_count -= 1
                if q.domination_count == 0:
                    q.rank = k + 2
                    next_front.append(q)
        k += 1
        if next_front:
            fronts.append(next_front)

    return fronts


def assign_crowding_distance(front: List["Individual"]) -> None:
    if not front:
        return

    for ind in front:
        ind.crowding = 0.0

    objectives = [
        ("f1_total_cost",),
        ("f2_max_route_duration",),
        ("f3_avg_route_duration",),
    ]

    n = len(front)
    if n <= 2:
        for ind in front:
            ind.crowding = float("inf")
        return

    for (attr,) in objectives:
        front.sort(key=lambda x: getattr(x, attr))

        front[0].crowding = float("inf")
        front[-1].crowding = float("inf")

        f_min = getattr(front[0], attr)
        f_max = getattr(front[-1], attr)
        denom = f_max - f_min

        if denom <= 1e-12:
            continue

        for i in range(1, n - 1):
            prev_v = getattr(front[i - 1], attr)
            next_v = getattr(front[i + 1], attr)
            front[i].crowding += (next_v - prev_v) / denom


def environmental_selection_elitist(
    parents: List["Individual"],
    offspring: List["Individual"],
    pop_size: int
) -> List["Individual"]:
    R = parents + offspring
    fronts = fast_non_dominated_sort(R)

    next_pop: List[Individual] = []
    for front in fronts:
        assign_crowding_distance(front)

        if len(next_pop) + len(front) <= pop_size:
            next_pop.extend(front)
        else:
            remaining = pop_size - len(next_pop)
            front.sort(key=lambda x: x.crowding, reverse=True)
            next_pop.extend(front[:remaining])
            break

    return next_pop


def tournament_pick(population: List["Individual"], rng: random.Random, k: int = 3) -> "Individual":
    contestants = rng.sample(population, k)
    best = contestants[0]
    for c in contestants[1:]:
        if c.rank < best.rank:
            best = c
        elif c.rank == best.rank and c.crowding > best.crowding:
            best = c
    return best


def build_mating_pool(population: List["Individual"], pool_size: int, seed: int = 123) -> List["Individual"]:
    rng = random.Random(seed)
    mating_pool: List[Individual] = []
    for _ in range(pool_size):
        mating_pool.append(tournament_pick(population, rng, k=2))
    return mating_pool


def prepare_rank_and_crowding(population: List["Individual"]) -> None:
    fronts = fast_non_dominated_sort(population)
    for front in fronts:
        assign_crowding_distance(front)



def segment_route_cost(route: List[int], dist: List[List[float]]) -> float:
   
    return FIXED_TAXI_COST + COST_PER_KM * route_distance(route, dist)


def decode_giant_tour_min_cost_dp_max_trucks(
    chromosome: List[int],
    dist: List[List[float]],
    demands: List[int],
    capacity: int,
    max_trucks: int,
    require_exact_k: bool = False
) -> Tuple[List[List[int]], float, int]:
   
    n = len(chromosome)
    INF = 1e30

    dp = [[INF] * (max_trucks + 1) for _ in range(n + 1)]
    prev_pos = [[-1] * (max_trucks + 1) for _ in range(n + 1)]
    prev_k = [[-1] * (max_trucks + 1) for _ in range(n + 1)]

    dp[0][0] = 0.0

    for i in range(n):
        for k in range(max_trucks):
            if dp[i][k] >= INF:
                continue

            load = 0
            for j in range(i + 1, n + 1):
                cust = chromosome[j - 1]
                load += demands[cust]
                if load > capacity:
                    break

                route = chromosome[i:j]
                c = segment_route_cost(route, dist)

                nk = k + 1
                if dp[i][k] + c < dp[j][nk]:
                    dp[j][nk] = dp[i][k] + c
                    prev_pos[j][nk] = i
                    prev_k[j][nk] = k

    
    if require_exact_k:
        best_k = max_trucks
        best_cost = dp[n][best_k]
        if best_cost >= INF:
            raise RuntimeError("Decode failed: exact k trucks infeasible.")
    else:
        best_k = -1
        best_cost = INF
        for k in range(1, max_trucks + 1):
            if dp[n][k] < best_cost:
                best_cost = dp[n][k]
                best_k = k
        if best_k == -1:
            raise RuntimeError("Decode failed: no feasible split within max_trucks.")

    #
    routes: List[List[int]] = []
    cur_pos = n
    cur_k = best_k
    while cur_pos > 0:
        i = prev_pos[cur_pos][cur_k]
        pk = prev_k[cur_pos][cur_k]
        if i < 0 or pk < 0:
            raise RuntimeError("Backtracking failed in decode.")
        routes.append(chromosome[i:cur_pos])
        cur_pos, cur_k = i, pk

    routes.reverse()
    return routes, best_cost, best_k


def evaluate_individual_vrp(ind: Individual, dist, time, demands, require_exact_k: bool) -> None:
    try:
        routes, total_cost, used_k = decode_giant_tour_min_cost_dp_max_trucks(
            ind.chromosome,
            dist,
            demands=demands,
            capacity=TAXI_CAPACITY,
            max_trucks=MAX_TRUCKS,
            require_exact_k=require_exact_k
        )

        durations = [route_duration(r, time) for r in routes]
        ind.f1_total_cost = total_cost
        ind.f2_max_route_duration = max(durations) if durations else 0.0
        ind.f3_avg_route_duration = (sum(durations) / len(durations)) if durations else 0.0

    except RuntimeError:
        
        BIG = 1e30
        ind.f1_total_cost = BIG
        ind.f2_max_route_duration = BIG
        ind.f3_avg_route_duration = BIG


def evaluate_population_vrp(pop, dist, time, demands, require_exact_k: bool) -> None:
    for ind in pop:
        evaluate_individual_vrp(ind, dist, time, demands, require_exact_k)



if __name__ == "__main__":
   
    REQUIRE_EXACT_K = False

    TSPLIB_TEXT = r"""
NAME : B-n66-k9
COMMENT : (Augerat et al, No of trucks: 9, Optimal value: 1316)
TYPE : CVRP
DIMENSION : 66
EDGE_WEIGHT_TYPE : EUC_2D 
CAPACITY : 100
NODE_COORD_SECTION 
 1 41 88
 2 53 83
 3 87 28
 4 42 11
 5 22 1
 6 34 36
 7 84 33
 8 81 63
 9 11 29
 10 62 27
 11 90 30
 12 84 69
 13 69 33
 14 89 72
 15 45 16
 16 28 6
 17 89 35
 18 58 88
 19 62 87
 20 88 67
 21 57 90
 22 54 0
 23 92 71
 24 63 86
 25 70 34
 26 91 35
 27 93 30
 28 39 44
 29 86 36
 30 43 13
 31 89 41
 32 85 70
 33 0 72
 34 18 39
 35 93 76
 36 90 65
 37 88 0
 38 91 36
 39 87 66
 40 45 14
 41 0 33
 42 54 89
 43 35 46
 44 91 73
 45 95 35
 46 85 71
 47 94 31
 48 88 37
 49 91 35
 50 66 34
 51 86 38
 52 92 77
 53 56 93
 54 58 91
 55 60 91
 56 61 84
 57 90 70
 58 85 67
 59 0 69
 60 94 35
 61 28 5
 62 89 37
 63 90 34
 64 94 32
 65 95 35
 66 16 32
DEMAND_SECTION 
1 0 
2 5 
3 20 
4 7 
5 2 
6 19 
7 19 
8 9 
9 15 
10 22 
11 14 
12 15 
13 18 
14 4 
15 6 
16 4 
17 10 
18 16 
19 14 
20 1 
21 23 
22 19 
23 16 
24 22 
25 15 
26 4 
27 21 
28 16 
29 22 
30 6 
31 2 
32 11 
33 5 
34 2 
35 12 
36 6 
37 17 
38 15 
39 11 
40 4 
41 22 
42 13 
43 21 
44 13 
45 20 
46 6 
47 15 
48 22 
49 11 
50 18 
51 8 
52 22 
53 16 
54 7 
55 16 
56 21 
57 16 
58 17 
59 16 
60 23 
61 3 
62 20 
63 13 
64 6 
65 12 
66 15 
DEPOT_SECTION 
 1  
 -1  
EOF  
""".strip()

    instance_name = parse_name(TSPLIB_TEXT) or "Unknown"
    k_from_name = parse_k_from_name(TSPLIB_TEXT)

    distance_matrix, time_matrix, demands, cap = parse_cvrp_tsplib(TSPLIB_TEXT)
    TAXI_CAPACITY = cap

    if k_from_name is not None:
        MAX_TRUCKS = k_from_name
    else:
        
        MAX_TRUCKS = 5

    n_customers = len(distance_matrix) - 1
    print(f"Loaded {instance_name} | customers={n_customers} | capacity={TAXI_CAPACITY} | max_trucks={MAX_TRUCKS} | exact_k={REQUIRE_EXACT_K}")
    print("demands[0..10] =", demands[:11], "...")

    pop_size = 100
    generations = 10000
    seed = 0
    rng = random.Random(seed)

    P = init_population(pop_size, n_customers, seed=seed)
    evaluate_population_vrp(P, distance_matrix, time_matrix, demands, REQUIRE_EXACT_K)
    apply_duplicate_penalty(P, penalty_step=15.0)
    BASE_MUT = 0.05   
    BOOST_MUT = 0.60  

    for gen in range(generations):
        prepare_rank_and_crowding(P)
        mut_rate = BASE_MUT
        if all(x.rank == 1 for x in P):
            mut_rate = BOOST_MUT

        mating_pool = build_mating_pool(P, pool_size=pop_size, seed=seed + 2000 + gen)
        Q = make_offspring(
            parents=mating_pool,
            rng=rng,
            crossover_rate=0.9,
            mutation_rate=mut_rate, 
            mutation_kind="inversion"
        )

        evaluate_population_vrp(Q, distance_matrix, time_matrix, demands, REQUIRE_EXACT_K)
        apply_duplicate_penalty(Q, penalty_step=15.0)
        P = environmental_selection_elitist(P, Q, pop_size)

        if (gen + 1) % 1 == 0:
            rank1_count = sum(1 for x in P if x.rank == 1)
            ranks = sorted(set(x.rank for x in P))
            print(f"Gen {gen+1:4d} | rank1 count: {rank1_count} | ranks present: {ranks[:10]}")

    prepare_rank_and_crowding(P)
    f1 = [x for x in P if x.rank == 1]
    print("\nFinal Rank-1 solutions:", len(f1))

    seen = set()
    shown = 0

    for i, ind in enumerate(
        sorted(f1, key=lambda z: (z.f1_total_cost, z.f2_max_route_duration, z.f3_avg_route_duration)), 1
    ):
        routes, total_cost, used_k = decode_giant_tour_min_cost_dp_max_trucks(
            ind.chromosome,
            distance_matrix,
            demands=demands,
            capacity=TAXI_CAPACITY,
            max_trucks=MAX_TRUCKS,
            require_exact_k=REQUIRE_EXACT_K
        )

        key = tuple(tuple(r) for r in routes)
        if key in seen:
            continue
        seen.add(key)

        durations = [route_duration(r, time_matrix) for r in routes]
        max_dur = max(durations) if durations else 0.0
        avg_dur = (sum(durations) / len(durations)) if durations else 0.0

        print(f"\n{i:2d}) f1(cost)={total_cost:.2f} | used_trucks={used_k} | f2(maxT)={max_dur:.2f} | f3(avgT)={avg_dur:.2f}")
        print("    chromosome:", ind.chromosome)
        print("    routes:")
        for k, r in enumerate(routes, 1):
            print(f"      truck{k}: [0] -> {r} -> [0]")

        shown += 1
        if shown >= 10:
            break
